<html>
  <head><meta charset="utf-8"></head>
  <body>
    <script async=true>
      const token = 'eyJhbGciOiJSUzI1NiIsImtpZCI6Imluc18xelJjclE4RDRWT0p2ZDljeHFvVFcyaUNUaXMiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2MzQxNDM4OTgsImlhdCI6MTYzNDE0MzgzOCwiaXNzIjoiaHR0cHM6Ly9jbGVyay5zZXJ2ZXJsZXNzLmNsZXJrLmFwcCIsIm5iZiI6MTYzNDE0MzgyOCwic2lkIjoic2Vzc18xelJ3S0Y1blVCclRpQjFWWW5Qcno5OVdodHYiLCJzdWIiOiJ1c2VyXzF6UndLR2FiNUNBaEY0c3p2enVFbWRFNVBocCJ9.XUiJev_QFDt4JQ671IxBq06wyzflRpcdirL6wE6hgYOXZKFkrua3rkx8RgFrr_vBVZww1HFbFv8QpKkeJgBTiv-vrvV_gj24UtaWluoHaNgaXWNgtAFVk2Fov4oEszX4ql6KZhR7xOaTU__wY5NNdJ57on3oFAw3zmjizO3cDQa477PQ39nDXogOv3Y8l5a0_5d-NhHLppv2ImB6LCpI22XMbIcLaYKq4af9z6g015UigpXLBsWxozBNmDRrTeIAK13bdHj42hfRlQfcxpMwvOy4G5aXht-HU3eenYoSHsjo_slgZEjz3p0XdkE6r4AClpa6-Ew3Pcu1XELEih36Tg';

      const pubKey = '-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAt3cmtkqQSWgUGiTz2j85\nWDHpozSHs9wAUEgzTnBQTEq7LBPQ/zSn4tHxI+7IO7J/EdjLI77dwh55DllEchY7\nboXR+nuuu56itC+pJq9GMrPrnFo/33cl0eJrEBXq1OBw65H0/GP4boHelKt1gJF9\n+kEiGE/En1CqYkso3+ARJZoRZwSty3pCe41iUJxzTaPnMbsUbGRQFDjAzfx3CpsP\nUloJr7+iscgkwZvkchc7b3DNyflOtVms20fNLN9COv0D4U7eu7ylmLKK5FZ5j05s\nySA9Ztsj3Vk5gKrKud1ESJ7dMYrOuKr5JPI/lhfO/NhajOUwXAex4YM6crJpyLNG\n7QIDAQAB\n-----END PUBLIC KEY-----'.replace(/\\n/g, '\n');

      function isExpired(decodedToken) {
        const claims = decodedToken.payload
        const now = Date.now().valueOf() / 1000

        if (typeof claims.exp !== 'undefined' && claims.exp < now) {
            throw new Error(`token expired: ${JSON.stringify(claims)}`)
        }
        if (typeof claims.nbf !== 'undefined' && claims.nbf > now) {
            throw new Error(`token expired: ${JSON.stringify(claims)}`)
        }
      }

      function decodeJwt(token) {
        const parts = token.split('.');
        const header = JSON.parse(atob(parts[0]));
        const payload = JSON.parse(atob(parts[1]));
        const signature = atob(parts[2].replace(/_/g, '/').replace(/-/g, '+'));
        return {
          header: header,
          payload: payload,
          signature: signature,
          raw: { header: parts[0], payload: parts[1], signature: parts[2] }
        }
      }

      // Convert a string into an ArrayBuffer from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
      function str2ab(str) {
          const buf = new ArrayBuffer(str.length);
          const bufView = new Uint8Array(buf);
          for (let i = 0, strLen = str.length; i < strLen; i++) {
              bufView[i] = str.charCodeAt(i);
          }
          return buf;
      }

      async function verify() {
          try {
              // fetch the part of the PEM string between header and footer
              // taken from
              // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#subjectpublickeyinfo_import
              const pemHeader = "-----BEGIN PUBLIC KEY-----";
              const pemFooter = "-----END PUBLIC KEY-----";
              const pemContents = pubKey.substring(pemHeader.length, pubKey.length - pemFooter.length);

              // base64 decode the string to get the binary data
              const binaryDerString = atob(pemContents);

              // convert from a binary string to an ArrayBuffer
              const binaryDer = str2ab(binaryDerString);

              // construct the CryptoKey
              const key = await crypto.subtle.importKey(
                  'spki',
                  binaryDer,
                  {
                      name: 'RSASSA-PKCS1-v1_5',
                      hash: 'SHA-256'
                  },
                  true,
                  ['verify']
              );


              const decodedToken = decodeJwt(token);
              const encoder = new TextEncoder();
              const data = encoder.encode([decodedToken.raw.header, decodedToken.raw.payload].join('.'));
              const signature = new Uint8Array(Array.from(decodedToken.signature).map(c => c.charCodeAt(0)));

              // verify exp+nbf
              if (isExpired(decodedToken)) {
                return false;
              }

              // verify signature
              return crypto.subtle.verify('RSASSA-PKCS1-v1_5', key, signature, data)
          } catch (e) {
              console.log('error occured in retrieveJWK(): ', e)
              throw new Error(e)
          }
      }

    </script>
  </body>
</html>
